//! Compositor integration setup for voxtype
//!
//! Provides configuration for various compositors to fix
//! modifier key interference when using compositor keybindings.

use crate::cli::CompositorType;
use crate::setup::{print_failure, print_info, print_success, print_warning};
use std::path::PathBuf;

/// Get the user's config directory (~/.config on Linux)
fn get_user_config_dir() -> PathBuf {
    directories::BaseDirs::new()
        .map(|d| d.config_dir().to_path_buf())
        .unwrap_or_else(|| {
            std::env::var("HOME")
                .map(|h| PathBuf::from(h).join(".config"))
                .unwrap_or_else(|_| PathBuf::from(".config"))
        })
}

/// Hyprland config file content
const HYPRLAND_CONFIG: &str = r#"# Voxtype compositor integration
# Fixes modifier key interference when using compositor keybindings
# Generated by: voxtype setup compositor hyprland
#
# Two submaps are used:
# - voxtype_recording: Active during recording/transcription. F12 cancels.
# - voxtype_suppress: Active during text output. Blocks modifier keys.
#
# NOTE: Do not bind Escape in voxtype_suppress. Binding Escape causes wtype's
# first character to be dropped. See: https://github.com/hyprwm/Hyprland/issues/3165

# Recording submap - active during recording and transcription
# F12 cancels recording/transcription and returns to normal
submap = voxtype_recording
bind = , F12, exec, voxtype record cancel
bind = , F12, submap, reset
submap = reset

# Output submap - blocks modifier keys during text output
submap = voxtype_suppress
bind = , SUPER_L, exec, true
bind = , SUPER_R, exec, true
bind = , Control_L, exec, true
bind = , Control_R, exec, true
bind = , Alt_L, exec, true
bind = , Alt_R, exec, true
bind = , Shift_L, exec, true
bind = , Shift_R, exec, true
bind = , F12, submap, reset  # Emergency escape if voxtype crashes
submap = reset
"#;

/// Sway config file content
const SWAY_CONFIG: &str = r#"# Voxtype compositor integration
# Fixes modifier key interference when using compositor keybindings
# Generated by: voxtype setup compositor sway
#
# Two modes are used:
# - voxtype_recording: Active during recording/transcription. F12 cancels.
# - voxtype_suppress: Active during text output. Blocks modifier keys.
#
# NOTE: Do not bind Escape in voxtype_suppress. Binding Escape causes wtype's
# first character to be dropped. See: https://github.com/hyprwm/Hyprland/issues/3165

# Recording mode - active during recording and transcription
mode "voxtype_recording" {
    bindsym F12 exec voxtype record cancel; mode "default"
}

# Output mode - blocks modifier keys during text output
mode "voxtype_suppress" {
    bindsym Super_L nop
    bindsym Super_R nop
    bindsym Control_L nop
    bindsym Control_R nop
    bindsym Alt_L nop
    bindsym Alt_R nop
    bindsym Shift_L nop
    bindsym Shift_R nop
    bindsym F12 mode "default"  # Emergency escape if voxtype crashes
}
"#;

/// Voxtype config snippet for Hyprland
const VOXTYPE_HYPRLAND_CONFIG: &str = r#"pre_recording_command = "hyprctl dispatch submap voxtype_recording"
pre_output_command = "hyprctl dispatch submap voxtype_suppress"
post_output_command = "hyprctl dispatch submap reset""#;

/// Voxtype config snippet for Sway
const VOXTYPE_SWAY_CONFIG: &str = r#"pre_recording_command = "swaymsg mode voxtype_recording"
pre_output_command = "swaymsg mode voxtype_suppress"
post_output_command = "swaymsg mode default""#;

/// River config file content (shell script for init)
const RIVER_CONFIG: &str = r#"#!/bin/sh
# Voxtype compositor integration for River
# Fixes modifier key interference when using compositor keybindings
# Generated by: voxtype setup compositor river
#
# Two modes are used:
# - voxtype_recording: Active during recording/transcription. F12 cancels.
# - voxtype_suppress: Active during text output. Blocks modifier keys.
#
# NOTE: Do not bind Escape in voxtype_suppress. Binding Escape causes wtype's
# first character to be dropped. See: https://github.com/hyprwm/Hyprland/issues/3165

# Declare the modes
riverctl declare-mode voxtype_recording
riverctl declare-mode voxtype_suppress

# Recording mode - F12 cancels recording/transcription
riverctl map voxtype_recording None F12 spawn "voxtype record cancel"
riverctl map voxtype_recording None F12 enter-mode normal

# Output mode - blocks modifier keys during text output
riverctl map voxtype_suppress None Super_L spawn true
riverctl map voxtype_suppress None Super_R spawn true
riverctl map voxtype_suppress None Control_L spawn true
riverctl map voxtype_suppress None Control_R spawn true
riverctl map voxtype_suppress None Alt_L spawn true
riverctl map voxtype_suppress None Alt_R spawn true
riverctl map voxtype_suppress None Shift_L spawn true
riverctl map voxtype_suppress None Shift_R spawn true
riverctl map voxtype_suppress None F12 enter-mode normal  # Emergency escape
"#;

/// Voxtype config snippet for River
const VOXTYPE_RIVER_CONFIG: &str = r#"pre_recording_command = "riverctl enter-mode voxtype_recording"
pre_output_command = "riverctl enter-mode voxtype_suppress"
post_output_command = "riverctl enter-mode normal""#;

/// Get the Hyprland conf.d directory
fn hyprland_conf_dir() -> PathBuf {
    get_user_config_dir().join("hypr/conf.d")
}

/// Get the Sway conf.d directory
fn sway_conf_dir() -> PathBuf {
    get_user_config_dir().join("sway/conf.d")
}

/// Get the River conf.d directory
fn river_conf_dir() -> PathBuf {
    get_user_config_dir().join("river/conf.d")
}

/// Get the voxtype config path
fn voxtype_config_path() -> PathBuf {
    get_user_config_dir().join("voxtype/config.toml")
}

/// Add output hooks to voxtype config content
/// Inserts hooks after the [output] section header
fn add_hooks_to_config(content: &str, hooks: &str) -> String {
    let mut result = String::new();
    let mut found_output_section = false;
    let mut hooks_inserted = false;

    for line in content.lines() {
        result.push_str(line);
        result.push('\n');

        // Look for [output] section (but not [output.notification] etc)
        if !hooks_inserted && line.trim() == "[output]" {
            found_output_section = true;
        }

        // Insert hooks after the first non-comment, non-empty line in [output] section
        // or after a blank line following [output]
        if found_output_section && !hooks_inserted {
            let trimmed = line.trim();
            if trimmed.is_empty()
                || (!trimmed.starts_with('#') && !trimmed.starts_with('[') && trimmed.contains('='))
            {
                // Found a good place to insert - after this line
                result.push('\n');
                result.push_str("# Compositor integration hooks (modifier key fix)\n");
                for hook_line in hooks.lines() {
                    result.push_str(hook_line);
                    result.push('\n');
                }
                hooks_inserted = true;
            }
        }
    }

    // If we found [output] but never inserted (empty section), append at end
    if found_output_section && !hooks_inserted {
        result.push_str("\n# Compositor integration hooks (modifier key fix)\n");
        for hook_line in hooks.lines() {
            result.push_str(hook_line);
            result.push('\n');
        }
    }

    result
}

/// Run compositor setup command
pub async fn run(compositor: &CompositorType) -> anyhow::Result<()> {
    match compositor {
        CompositorType::Hyprland {
            uninstall,
            status,
            show,
        } => {
            if *show {
                print_hyprland_config();
            } else if *status {
                hyprland_status();
            } else if *uninstall {
                hyprland_uninstall()?;
            } else {
                hyprland_install()?;
            }
        }
        CompositorType::Sway {
            uninstall,
            status,
            show,
        } => {
            if *show {
                print_sway_config();
            } else if *status {
                sway_status();
            } else if *uninstall {
                sway_uninstall()?;
            } else {
                sway_install()?;
            }
        }
        CompositorType::River {
            uninstall,
            status,
            show,
        } => {
            if *show {
                print_river_config();
            } else if *status {
                river_status();
            } else if *uninstall {
                river_uninstall()?;
            } else {
                river_install()?;
            }
        }
    }
    Ok(())
}

// ============================================================================
// Hyprland
// ============================================================================

fn hyprland_install() -> anyhow::Result<()> {
    let conf_dir = hyprland_conf_dir();
    let conf_file = conf_dir.join("voxtype-submap.conf");
    let hyprland_conf = get_user_config_dir().join("hypr/hyprland.conf");

    println!("Installing Hyprland integration...\n");

    // Check if hyprland.conf sources conf.d
    let (sources_conf_d, has_commented) = if hyprland_conf.exists() {
        let content = std::fs::read_to_string(&hyprland_conf).unwrap_or_default();
        let active = content.lines().any(|line| {
            let trimmed = line.trim();
            !trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        let commented = content.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        (active, commented)
    } else {
        (false, false)
    };

    if !sources_conf_d {
        print_warning("hyprland.conf does not source conf.d directory");
        if has_commented {
            println!("       Uncomment this line in ~/.config/hypr/hyprland.conf:\n");
            println!("       source = ~/.config/hypr/conf.d/*.conf\n");
        } else {
            println!("       Add this line to ~/.config/hypr/hyprland.conf:\n");
            println!("       source = ~/.config/hypr/conf.d/*.conf\n");
        }
    }

    // Create conf.d directory if needed
    if !conf_dir.exists() {
        std::fs::create_dir_all(&conf_dir)?;
        print_success(&format!("Created {:?}", conf_dir));
    }

    // Write the config file
    std::fs::write(&conf_file, HYPRLAND_CONFIG)?;
    print_success(&format!("Wrote {:?}", conf_file));

    // Install output hooks in voxtype config
    let voxtype_config = voxtype_config_path();
    if voxtype_config.exists() {
        let content = std::fs::read_to_string(&voxtype_config)?;
        if content.contains("pre_output_command") || content.contains("pre_recording_command") {
            print_success("Voxtype config already has compositor hooks");
        } else {
            // Add hooks to the [output] section
            let new_content = add_hooks_to_config(&content, VOXTYPE_HYPRLAND_CONFIG);
            std::fs::write(&voxtype_config, new_content)?;
            print_success("Added compositor hooks to voxtype config");
        }
    } else {
        print_warning("Voxtype config not found");
        println!("       Run: voxtype setup");
    }

    println!("\n---");
    println!("\x1b[32m✓ Hyprland integration installed!\x1b[0m\n");
    println!("Next steps:");
    println!("  1. Reload Hyprland: hyprctl reload");
    println!("  2. Restart voxtype: systemctl --user restart voxtype");
    println!("\nIf voxtype crashes while typing, press F12 to escape the submap.");

    Ok(())
}

fn hyprland_uninstall() -> anyhow::Result<()> {
    let conf_file = hyprland_conf_dir().join("voxtype-submap.conf");

    println!("Uninstalling Hyprland integration...\n");

    if conf_file.exists() {
        std::fs::remove_file(&conf_file)?;
        print_success(&format!("Removed {:?}", conf_file));
    } else {
        print_info("Config file not found (already uninstalled)");
    }

    print_warning("Remember to remove compositor hooks from voxtype config if no longer needed");
    println!("\n---");
    println!("\x1b[32m✓ Hyprland integration uninstalled!\x1b[0m");
    println!("\nReload Hyprland: hyprctl reload");

    Ok(())
}

fn hyprland_status() {
    let conf_file = hyprland_conf_dir().join("voxtype-submap.conf");
    let voxtype_config = voxtype_config_path();

    println!("Hyprland Integration Status\n");

    // Check compositor config
    if conf_file.exists() {
        print_success(&format!("Compositor config: {:?}", conf_file));
    } else {
        print_failure("Compositor config: not installed");
        println!("       Run: voxtype setup compositor hyprland");
    }

    // Check voxtype hooks
    if voxtype_config.exists() {
        if let Ok(content) = std::fs::read_to_string(&voxtype_config) {
            if content.contains("pre_recording_command") && content.contains("hyprctl") {
                print_success("Voxtype hooks: configured for Hyprland (with recording hook)");
            } else if content.contains("pre_output_command") && content.contains("hyprctl") {
                print_warning(
                    "Voxtype hooks: configured for Hyprland (missing pre_recording_command)",
                );
                println!("       Add to [output] section:\n");
                println!(
                    "       pre_recording_command = \"hyprctl dispatch submap voxtype_recording\""
                );
            } else if content.contains("pre_output_command") {
                print_warning("Voxtype hooks: configured (but not for Hyprland)");
            } else {
                print_failure("Voxtype hooks: not configured");
                println!("       Add to [output] section:\n");
                println!("       {}", VOXTYPE_HYPRLAND_CONFIG);
            }
        }
    } else {
        print_failure("Voxtype config: not found");
    }
}

fn print_hyprland_config() {
    println!("Hyprland Integration for Voxtype");
    println!("=================================\n");

    println!("When using compositor keybindings with modifiers (e.g., SUPER+CTRL+X),");
    println!("if keys are released slowly, voxtype may start typing while modifier");
    println!("keys are still held down. This causes typed characters to trigger");
    println!("compositor shortcuts instead of inserting text.");
    println!("\nThis configuration fixes that issue by temporarily blocking modifiers.\n");

    println!("\x1b[1mCompositor config (~/.config/hypr/conf.d/voxtype-submap.conf):\x1b[0m\n");
    println!("{}", HYPRLAND_CONFIG);

    println!("\x1b[1mVoxtype config (~/.config/voxtype/config.toml [output] section):\x1b[0m\n");
    println!("{}\n", VOXTYPE_HYPRLAND_CONFIG);

    println!("---");
    println!("To install automatically: voxtype setup compositor hyprland");
    println!("If voxtype crashes while typing, press F12 to escape the submap.");
}

// ============================================================================
// Sway
// ============================================================================

fn sway_install() -> anyhow::Result<()> {
    let conf_dir = sway_conf_dir();
    let conf_file = conf_dir.join("voxtype-mode.conf");
    let sway_conf = get_user_config_dir().join("sway/config");

    println!("Installing Sway integration...\n");

    // Check if sway config includes conf.d
    let (includes_conf_d, has_commented) = if sway_conf.exists() {
        let content = std::fs::read_to_string(&sway_conf).unwrap_or_default();
        let active = content.lines().any(|line| {
            let trimmed = line.trim();
            !trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        let commented = content.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        (active, commented)
    } else {
        (false, false)
    };

    if !includes_conf_d {
        print_warning("Sway config does not include conf.d directory");
        if has_commented {
            println!("       Uncomment this line in ~/.config/sway/config:\n");
            println!("       include ~/.config/sway/conf.d/*.conf\n");
        } else {
            println!("       Add this line to ~/.config/sway/config:\n");
            println!("       include ~/.config/sway/conf.d/*.conf\n");
        }
    }

    // Create conf.d directory if needed
    if !conf_dir.exists() {
        std::fs::create_dir_all(&conf_dir)?;
        print_success(&format!("Created {:?}", conf_dir));
    }

    // Write the config file
    std::fs::write(&conf_file, SWAY_CONFIG)?;
    print_success(&format!("Wrote {:?}", conf_file));

    // Install output hooks in voxtype config
    let voxtype_config = voxtype_config_path();
    if voxtype_config.exists() {
        let content = std::fs::read_to_string(&voxtype_config)?;
        if content.contains("pre_output_command") || content.contains("pre_recording_command") {
            print_success("Voxtype config already has compositor hooks");
        } else {
            // Add hooks to the [output] section
            let new_content = add_hooks_to_config(&content, VOXTYPE_SWAY_CONFIG);
            std::fs::write(&voxtype_config, new_content)?;
            print_success("Added compositor hooks to voxtype config");
        }
    } else {
        print_warning("Voxtype config not found");
        println!("       Run: voxtype setup");
    }

    println!("\n---");
    println!("\x1b[32m✓ Sway integration installed!\x1b[0m\n");
    println!("Next steps:");
    println!("  1. Reload Sway: swaymsg reload");
    println!("  2. Restart voxtype: systemctl --user restart voxtype");
    println!("\nIf voxtype crashes while typing, press F12 to escape the mode.");

    Ok(())
}

fn sway_uninstall() -> anyhow::Result<()> {
    let conf_file = sway_conf_dir().join("voxtype-mode.conf");

    println!("Uninstalling Sway integration...\n");

    if conf_file.exists() {
        std::fs::remove_file(&conf_file)?;
        print_success(&format!("Removed {:?}", conf_file));
    } else {
        print_info("Config file not found (already uninstalled)");
    }

    print_warning("Remember to remove compositor hooks from voxtype config if no longer needed");
    println!("\n---");
    println!("\x1b[32m✓ Sway integration uninstalled!\x1b[0m");
    println!("\nReload Sway: swaymsg reload");

    Ok(())
}

fn sway_status() {
    let conf_file = sway_conf_dir().join("voxtype-mode.conf");
    let voxtype_config = voxtype_config_path();

    println!("Sway Integration Status\n");

    // Check compositor config
    if conf_file.exists() {
        print_success(&format!("Compositor config: {:?}", conf_file));
    } else {
        print_failure("Compositor config: not installed");
        println!("       Run: voxtype setup compositor sway");
    }

    // Check voxtype hooks
    if voxtype_config.exists() {
        if let Ok(content) = std::fs::read_to_string(&voxtype_config) {
            if content.contains("pre_recording_command") && content.contains("swaymsg") {
                print_success("Voxtype hooks: configured for Sway (with recording hook)");
            } else if content.contains("pre_output_command") && content.contains("swaymsg") {
                print_warning("Voxtype hooks: configured for Sway (missing pre_recording_command)");
                println!("       Add to [output] section:\n");
                println!("       pre_recording_command = \"swaymsg mode voxtype_recording\"");
            } else if content.contains("pre_output_command") {
                print_warning("Voxtype hooks: configured (but not for Sway)");
            } else {
                print_failure("Voxtype hooks: not configured");
                println!("       Add to [output] section:\n");
                println!("       {}", VOXTYPE_SWAY_CONFIG);
            }
        }
    } else {
        print_failure("Voxtype config: not found");
    }
}

fn print_sway_config() {
    println!("Sway Integration for Voxtype");
    println!("============================\n");

    println!("When using compositor keybindings with modifiers (e.g., $mod+Ctrl+x),");
    println!("if keys are released slowly, voxtype may start typing while modifier");
    println!("keys are still held down. This causes typed characters to trigger");
    println!("compositor shortcuts instead of inserting text.");
    println!("\nThis configuration fixes that issue by temporarily blocking modifiers.\n");

    println!("\x1b[1mCompositor config (~/.config/sway/conf.d/voxtype-mode.conf):\x1b[0m\n");
    println!("{}", SWAY_CONFIG);

    println!("\x1b[1mVoxtype config (~/.config/voxtype/config.toml [output] section):\x1b[0m\n");
    println!("{}\n", VOXTYPE_SWAY_CONFIG);

    println!("---");
    println!("To install automatically: voxtype setup compositor sway");
    println!("If voxtype crashes while typing, press F12 to escape the mode.");
}

// ============================================================================
// River
// ============================================================================

fn river_install() -> anyhow::Result<()> {
    let conf_dir = river_conf_dir();
    let conf_file = conf_dir.join("voxtype-mode.sh");
    let river_init = get_user_config_dir().join("river/init");

    println!("Installing River integration...\n");

    // Check if river init sources conf.d
    let (sources_conf_d, has_commented) = if river_init.exists() {
        let content = std::fs::read_to_string(&river_init).unwrap_or_default();
        let active = content.lines().any(|line| {
            let trimmed = line.trim();
            !trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        let commented = content.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        (active, commented)
    } else {
        (false, false)
    };

    if !sources_conf_d {
        print_warning("River init does not source conf.d directory");
        if has_commented {
            println!("       Uncomment the conf.d sourcing line in ~/.config/river/init\n");
        } else {
            println!("       Add this to ~/.config/river/init:\n");
            println!("       for conf in ~/.config/river/conf.d/*.sh; do");
            println!("           [ -r \"$conf\" ] && . \"$conf\"");
            println!("       done\n");
        }
    }

    // Create conf.d directory if needed
    if !conf_dir.exists() {
        std::fs::create_dir_all(&conf_dir)?;
        print_success(&format!("Created {:?}", conf_dir));
    }

    // Write the config file
    std::fs::write(&conf_file, RIVER_CONFIG)?;
    // Make it executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = std::fs::metadata(&conf_file)?.permissions();
        perms.set_mode(0o755);
        std::fs::set_permissions(&conf_file, perms)?;
    }
    print_success(&format!("Wrote {:?}", conf_file));

    // Install output hooks in voxtype config
    let voxtype_config = voxtype_config_path();
    if voxtype_config.exists() {
        let content = std::fs::read_to_string(&voxtype_config)?;
        if content.contains("pre_output_command") || content.contains("pre_recording_command") {
            print_success("Voxtype config already has compositor hooks");
        } else {
            // Add hooks to the [output] section
            let new_content = add_hooks_to_config(&content, VOXTYPE_RIVER_CONFIG);
            std::fs::write(&voxtype_config, new_content)?;
            print_success("Added compositor hooks to voxtype config");
        }
    } else {
        print_warning("Voxtype config not found");
        println!("       Run: voxtype setup");
    }

    println!("\n---");
    println!("\x1b[32m✓ River integration installed!\x1b[0m\n");
    println!("Next steps:");
    println!("  1. Restart River or source the config: . ~/.config/river/conf.d/voxtype-mode.sh");
    println!("  2. Restart voxtype: systemctl --user restart voxtype");
    println!("\nIf voxtype crashes while typing, press F12 to escape the mode.");

    Ok(())
}

fn river_uninstall() -> anyhow::Result<()> {
    let conf_file = river_conf_dir().join("voxtype-mode.sh");

    println!("Uninstalling River integration...\n");

    if conf_file.exists() {
        std::fs::remove_file(&conf_file)?;
        print_success(&format!("Removed {:?}", conf_file));
    } else {
        print_info("Config file not found (already uninstalled)");
    }

    print_warning("Remember to remove compositor hooks from voxtype config if no longer needed");
    println!("\n---");
    println!("\x1b[32m✓ River integration uninstalled!\x1b[0m");
    println!("\nRestart River to apply changes.");

    Ok(())
}

fn river_status() {
    let conf_file = river_conf_dir().join("voxtype-mode.sh");
    let voxtype_config = voxtype_config_path();

    println!("River Integration Status\n");

    // Check compositor config
    if conf_file.exists() {
        print_success(&format!("Compositor config: {:?}", conf_file));
    } else {
        print_failure("Compositor config: not installed");
        println!("       Run: voxtype setup compositor river");
    }

    // Check voxtype hooks
    if voxtype_config.exists() {
        if let Ok(content) = std::fs::read_to_string(&voxtype_config) {
            if content.contains("pre_recording_command") && content.contains("riverctl") {
                print_success("Voxtype hooks: configured for River (with recording hook)");
            } else if content.contains("pre_output_command") && content.contains("riverctl") {
                print_warning(
                    "Voxtype hooks: configured for River (missing pre_recording_command)",
                );
                println!("       Add to [output] section:\n");
                println!(
                    "       pre_recording_command = \"riverctl enter-mode voxtype_recording\""
                );
            } else if content.contains("pre_output_command") {
                print_warning("Voxtype hooks: configured (but not for River)");
            } else {
                print_failure("Voxtype hooks: not configured");
                println!("       Add to [output] section:\n");
                println!("       {}", VOXTYPE_RIVER_CONFIG);
            }
        }
    } else {
        print_failure("Voxtype config: not found");
    }
}

fn print_river_config() {
    println!("River Integration for Voxtype");
    println!("=============================\n");

    println!("When using compositor keybindings with modifiers (e.g., Super+Control+X),");
    println!("if keys are released slowly, voxtype may start typing while modifier");
    println!("keys are still held down. This causes typed characters to trigger");
    println!("compositor shortcuts instead of inserting text.");
    println!("\nThis configuration fixes that issue by temporarily blocking modifiers.\n");

    println!("\x1b[1mCompositor config (~/.config/river/conf.d/voxtype-mode.sh):\x1b[0m\n");
    println!("{}", RIVER_CONFIG);

    println!("\x1b[1mVoxtype config (~/.config/voxtype/config.toml [output] section):\x1b[0m\n");
    println!("{}\n", VOXTYPE_RIVER_CONFIG);

    println!("---");
    println!("To install automatically: voxtype setup compositor river");
    println!("If voxtype crashes while typing, press F12 to escape the mode.");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add_hooks_to_config_basic() {
        let config = r#"[output]
mode = "type"
fallback_to_clipboard = true
"#;
        let hooks = r#"pre_output_command = "test"
post_output_command = "test2""#;

        let result = add_hooks_to_config(config, hooks);

        assert!(result.contains("pre_output_command"));
        assert!(result.contains("post_output_command"));
        assert!(result.contains("# Compositor integration hooks"));
        // Should only have one occurrence
        assert_eq!(result.matches("pre_output_command").count(), 1);
    }

    #[test]
    fn test_add_hooks_preserves_existing_content() {
        let config = r#"[hotkey]
key = "HOME"

[output]
mode = "type"

[audio]
device = "default"
"#;
        let hooks = r#"pre_output_command = "test""#;

        let result = add_hooks_to_config(config, hooks);

        assert!(result.contains("[hotkey]"));
        assert!(result.contains("key = \"HOME\""));
        assert!(result.contains("[audio]"));
        assert!(result.contains("device = \"default\""));
        assert!(result.contains("pre_output_command"));
    }

    #[test]
    fn test_add_hooks_after_output_section() {
        let config = r#"[output]
mode = "type"
"#;
        let hooks = r#"pre_output_command = "hyprctl dispatch submap voxtype_suppress""#;

        let result = add_hooks_to_config(config, hooks);

        // Hooks should appear after [output] section
        let output_pos = result.find("[output]").unwrap();
        let hooks_pos = result.find("pre_output_command").unwrap();
        assert!(hooks_pos > output_pos);
    }

    #[test]
    fn test_add_hooks_does_not_duplicate() {
        let config = r#"[output]
mode = "type"
pre_output_command = "existing"
"#;
        let hooks = r#"pre_output_command = "new""#;

        // The install function checks for existing hooks before calling add_hooks_to_config,
        // but let's verify the function itself doesn't break anything
        let result = add_hooks_to_config(config, hooks);

        // Should have added hooks (the check is done at call site, not in this function)
        assert!(result.contains("pre_output_command"));
    }

    #[test]
    fn test_detect_conf_d_source_active() {
        let config = "source = ~/.config/hypr/conf.d/*.conf";
        let active = config.lines().any(|line| {
            let trimmed = line.trim();
            !trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        assert!(active);
    }

    #[test]
    fn test_detect_conf_d_source_commented() {
        let config = "# source = ~/.config/hypr/conf.d/*.conf";
        let active = config.lines().any(|line| {
            let trimmed = line.trim();
            !trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        let commented = config.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        assert!(!active);
        assert!(commented);
    }

    #[test]
    fn test_detect_conf_d_source_missing() {
        let config = r#"
monitor=DP-1,preferred,auto,1
bind = SUPER, RETURN, exec, kitty
"#;
        let active = config.lines().any(|line| {
            let trimmed = line.trim();
            !trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        let commented = config.lines().any(|line| {
            let trimmed = line.trim();
            trimmed.starts_with('#') && trimmed.contains("conf.d")
        });
        assert!(!active);
        assert!(!commented);
    }

    #[test]
    fn test_hyprland_config_contains_submaps() {
        // Recording submap for cancel during recording/transcription
        assert!(HYPRLAND_CONFIG.contains("submap = voxtype_recording"));
        // Output submap for modifier suppression
        assert!(HYPRLAND_CONFIG.contains("submap = voxtype_suppress"));
        assert!(HYPRLAND_CONFIG.contains("SUPER_L"));
        assert!(HYPRLAND_CONFIG.contains("F12"));
        assert!(HYPRLAND_CONFIG.contains("submap = reset"));
    }

    #[test]
    fn test_sway_config_contains_modes() {
        // Recording mode for cancel during recording/transcription
        assert!(SWAY_CONFIG.contains("mode \"voxtype_recording\""));
        // Output mode for modifier suppression
        assert!(SWAY_CONFIG.contains("mode \"voxtype_suppress\""));
        assert!(SWAY_CONFIG.contains("Super_L"));
        assert!(SWAY_CONFIG.contains("F12"));
        assert!(SWAY_CONFIG.contains("mode \"default\""));
    }

    #[test]
    fn test_voxtype_hyprland_hooks() {
        assert!(VOXTYPE_HYPRLAND_CONFIG.contains("pre_recording_command"));
        assert!(VOXTYPE_HYPRLAND_CONFIG.contains("hyprctl dispatch submap voxtype_recording"));
        assert!(VOXTYPE_HYPRLAND_CONFIG.contains("hyprctl dispatch submap voxtype_suppress"));
        assert!(VOXTYPE_HYPRLAND_CONFIG.contains("hyprctl dispatch submap reset"));
    }

    #[test]
    fn test_voxtype_sway_hooks() {
        assert!(VOXTYPE_SWAY_CONFIG.contains("pre_recording_command"));
        assert!(VOXTYPE_SWAY_CONFIG.contains("swaymsg mode voxtype_recording"));
        assert!(VOXTYPE_SWAY_CONFIG.contains("swaymsg mode voxtype_suppress"));
        assert!(VOXTYPE_SWAY_CONFIG.contains("swaymsg mode default"));
    }

    #[test]
    fn test_river_config_contains_modes() {
        // Recording mode for cancel during recording/transcription
        assert!(RIVER_CONFIG.contains("declare-mode voxtype_recording"));
        // Output mode for modifier suppression
        assert!(RIVER_CONFIG.contains("declare-mode voxtype_suppress"));
        assert!(RIVER_CONFIG.contains("Super_L"));
        assert!(RIVER_CONFIG.contains("F12"));
        assert!(RIVER_CONFIG.contains("enter-mode normal"));
    }

    #[test]
    fn test_voxtype_river_hooks() {
        assert!(VOXTYPE_RIVER_CONFIG.contains("pre_recording_command"));
        assert!(VOXTYPE_RIVER_CONFIG.contains("riverctl enter-mode voxtype_recording"));
        assert!(VOXTYPE_RIVER_CONFIG.contains("riverctl enter-mode voxtype_suppress"));
        assert!(VOXTYPE_RIVER_CONFIG.contains("riverctl enter-mode normal"));
    }
}
