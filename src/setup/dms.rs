//! DankMaterialShell (DMS) integration for voxtype
//!
//! Generates a QML plugin widget that displays voxtype status in DankMaterialShell.

use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;

use crate::error::VoxtypeError;
use crate::setup::get_voxtype_path;

/// Get the DMS plugins directory (~/.config/DankMaterialShell/plugins/)
fn get_plugins_dir() -> PathBuf {
    directories::BaseDirs::new()
        .map(|d| {
            d.config_dir()
                .join("DankMaterialShell")
                .join("plugins")
                .to_path_buf()
        })
        .unwrap_or_else(|| {
            std::env::var("HOME")
                .map(|h| {
                    PathBuf::from(h)
                        .join(".config")
                        .join("DankMaterialShell")
                        .join("plugins")
                })
                .unwrap_or_else(|_| PathBuf::from(".config/DankMaterialShell/plugins"))
        })
}

/// Get the VoxtypeWidget plugin directory
fn get_widget_dir() -> PathBuf {
    get_plugins_dir().join("VoxtypeWidget")
}

/// Get the QML file path
fn get_qml_path() -> PathBuf {
    get_widget_dir().join("Voxtype.qml")
}

/// The QML template with VOXTYPE_PATH as a placeholder
const QML_TEMPLATE: &str = r##"import QtQuick
import QtQuick.Layouts
import QtQuick.Controls

// Voxtype Status Widget for DankMaterialShell
// Generated by: voxtype setup dms
// Polls voxtype status every 500ms and displays state with icons

Item {
    id: voxtypeWidget
    implicitWidth: statusText.implicitWidth + 16
    implicitHeight: 32

    property string currentState: "stopped"
    property string statusIcon: "\uf131"  // mic-slash (stopped)
    property color statusColor: "#6272a4"

    // State to icon/color mapping (Nerd Font icons)
    readonly property var stateConfig: ({
        "idle": { icon: "\uf130", color: "#50fa7b" },      // mic (green)
        "recording": { icon: "\uf111", color: "#ff5555" }, // dot (red)
        "transcribing": { icon: "\uf110", color: "#f1fa8c" }, // spinner (yellow)
        "stopped": { icon: "\uf131", color: "#6272a4" }    // mic-slash (gray)
    })

    Timer {
        id: pollTimer
        interval: 500
        running: true
        repeat: true
        onTriggered: {
            statusProcess.start("VOXTYPE_PATH", ["status"])
        }
    }

    Process {
        id: statusProcess
        onReadyReadStandardOutput: {
            var output = readAllStandardOutput().toString().trim()
            if (output && output !== currentState) {
                currentState = output
                var config = stateConfig[currentState] || stateConfig["stopped"]
                statusIcon = config.icon
                statusColor = config.color
            }
        }
    }

    RowLayout {
        anchors.fill: parent
        spacing: 4

        Text {
            id: statusText
            text: statusIcon
            font.family: "Symbols Nerd Font"
            font.pixelSize: 14
            color: statusColor
            Layout.alignment: Qt.AlignVCenter

            // Pulse animation for recording state
            SequentialAnimation on opacity {
                running: currentState === "recording"
                loops: Animation.Infinite
                NumberAnimation { to: 0.5; duration: 500; easing.type: Easing.InOutQuad }
                NumberAnimation { to: 1.0; duration: 500; easing.type: Easing.InOutQuad }
            }
        }
    }

    MouseArea {
        id: mouseArea
        anchors.fill: parent
        hoverEnabled: true
        onClicked: {
            // Toggle recording on click
            toggleProcess.start("VOXTYPE_PATH", ["record", "toggle"])
        }
    }

    Process {
        id: toggleProcess
    }

    // Tooltip
    ToolTip {
        visible: mouseArea.containsMouse
        text: {
            switch (currentState) {
                case "recording": return "Recording... (click to stop)"
                case "transcribing": return "Transcribing..."
                case "idle": return "Voxtype ready (click to record)"
                default: return "Voxtype not running"
            }
        }
    }

    Component.onCompleted: {
        // Initial status check
        statusProcess.start("VOXTYPE_PATH", ["status"])
    }
}
"##;

/// Generate the QML plugin content with the correct voxtype path
fn get_qml_content() -> String {
    let voxtype_path = get_voxtype_path();
    QML_TEMPLATE.replace("VOXTYPE_PATH", &voxtype_path)
}

/// Install DMS integration (create plugin directory and QML file)
pub fn install() -> Result<(), VoxtypeError> {
    let widget_dir = get_widget_dir();
    let qml_path = get_qml_path();

    // Check if DMS config directory exists
    let dms_config = get_plugins_dir()
        .parent()
        .map(|p| p.to_path_buf())
        .unwrap_or_else(get_plugins_dir);

    if !dms_config.exists() {
        eprintln!("DankMaterialShell config directory not found at:");
        eprintln!("  {}", dms_config.display());
        eprintln!("\nPlease install DankMaterialShell first.");
        return Err(VoxtypeError::Config(
            "DankMaterialShell config not found".into(),
        ));
    }

    // Check if plugin already exists
    if qml_path.exists() {
        println!("Voxtype widget already exists at:");
        println!("  {}", qml_path.display());
        println!("\nUse --uninstall first if you want to reinstall.");
        return Ok(());
    }

    // Prompt for confirmation
    println!("This will create a DankMaterialShell plugin for Voxtype:");
    println!("  Directory: {}", widget_dir.display());
    println!("  Widget:    {}", qml_path.display());
    print!("\nProceed with installation? [y/N] ");
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    if !input.trim().eq_ignore_ascii_case("y") {
        println!("Installation cancelled.");
        return Ok(());
    }

    // Create plugin directory
    fs::create_dir_all(&widget_dir)
        .map_err(|e| VoxtypeError::Config(format!("Failed to create plugin directory: {}", e)))?;
    println!("Created directory: {}", widget_dir.display());

    // Write QML file
    fs::write(&qml_path, get_qml_content())
        .map_err(|e| VoxtypeError::Config(format!("Failed to write QML file: {}", e)))?;
    println!("Created widget: {}", qml_path.display());

    println!("\nDankMaterialShell integration installed successfully!");
    println!();
    println!("To enable the widget:");
    println!("  1. Open DankMaterialShell settings");
    println!("  2. Navigate to the Plugins section");
    println!("  3. Enable the VoxtypeWidget plugin");
    println!("  4. Add the Voxtype widget to your panel");
    println!();
    println!("Note: The widget requires a Nerd Font for icons to display correctly.");
    println!("      If icons appear as boxes, install a Nerd Font:");
    println!("      https://www.nerdfonts.com/");

    Ok(())
}

/// Uninstall DMS integration (remove plugin directory)
pub fn uninstall() -> Result<(), VoxtypeError> {
    let widget_dir = get_widget_dir();

    if !widget_dir.exists() {
        println!("Voxtype widget not found, nothing to uninstall.");
        return Ok(());
    }

    // Prompt for confirmation
    println!("This will remove the Voxtype widget:");
    println!("  {}", widget_dir.display());
    print!("\nRemove Voxtype from DankMaterialShell? [y/N] ");
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    if !input.trim().eq_ignore_ascii_case("y") {
        println!("Uninstall cancelled.");
        return Ok(());
    }

    // Remove plugin directory
    fs::remove_dir_all(&widget_dir)
        .map_err(|e| VoxtypeError::Config(format!("Failed to remove plugin directory: {}", e)))?;
    println!("Removed: {}", widget_dir.display());

    println!("\nDankMaterialShell integration removed.");
    println!("Restart DankMaterialShell to apply changes.");

    Ok(())
}

/// The simplified QML template for print_config (manual setup instructions)
const QML_SIMPLE_TEMPLATE: &str = r##"import QtQuick
import QtQuick.Layouts

Item {
    id: voxtypeWidget
    implicitWidth: statusText.implicitWidth + 16
    implicitHeight: 32

    property string currentState: "stopped"
    property string statusIcon: "\uf131"
    property color statusColor: "#6272a4"

    readonly property var stateConfig: ({
        "idle": { icon: "\uf130", color: "#50fa7b" },
        "recording": { icon: "\uf111", color: "#ff5555" },
        "transcribing": { icon: "\uf110", color: "#f1fa8c" },
        "stopped": { icon: "\uf131", color: "#6272a4" }
    })

    Timer {
        interval: 500
        running: true
        repeat: true
        onTriggered: statusProcess.start("VOXTYPE_PATH", ["status"])
    }

    Process {
        id: statusProcess
        onReadyReadStandardOutput: {
            var output = readAllStandardOutput().toString().trim()
            if (output && output !== currentState) {
                currentState = output
                var config = stateConfig[currentState] || stateConfig["stopped"]
                statusIcon = config.icon
                statusColor = config.color
            }
        }
    }

    Text {
        id: statusText
        anchors.centerIn: parent
        text: statusIcon
        font.family: "Symbols Nerd Font"
        font.pixelSize: 14
        color: statusColor
    }

    MouseArea {
        anchors.fill: parent
        onClicked: toggleProcess.start("VOXTYPE_PATH", ["record", "toggle"])
    }

    Process { id: toggleProcess }
}"##;

/// Print DMS configuration instructions
pub fn print_config() {
    let voxtype_path = get_voxtype_path();

    println!("DankMaterialShell Configuration for Voxtype\n");
    println!("============================================\n");

    println!("Run 'voxtype setup dms --install' to automatically install the widget.\n");

    println!("Or manually create the widget:\n");
    println!(
        "1. Create the plugin directory:\n   mkdir -p ~/.config/DankMaterialShell/plugins/VoxtypeWidget\n"
    );
    println!("2. Create ~/.config/DankMaterialShell/plugins/VoxtypeWidget/Voxtype.qml\n");
    println!("   with the following content:\n");

    // Print the simplified QML with the actual path substituted
    println!(
        "{}",
        QML_SIMPLE_TEMPLATE.replace("VOXTYPE_PATH", &voxtype_path)
    );

    println!("\n\n3. Enable the widget in DankMaterialShell settings.\n");

    println!("---");
    println!("\nRequirements:");
    println!("  - DankMaterialShell installed and running");
    println!("  - Nerd Font installed for icons (https://www.nerdfonts.com/)");
    println!("  - state_file = \"auto\" in voxtype config.toml");
    println!("\nFor more details, see: https://voxtype.io");
}

/// Get the QML content (for programmatic use)
pub fn get_qml_config() -> String {
    get_qml_content()
}
